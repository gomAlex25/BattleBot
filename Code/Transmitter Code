#include <msp430.h>
#include <stdint.h>

// --- TIMER B0: 38 kHz Carrier Wave on P2.7/TB0.6 ---
#define PWM_PERIOD          209     // TB0CCR0 for 38.095 kHz at 8 MHz SMCLK
#define DUTY_CYCLE_50       104

// --- TIMER A0: Timing Clock Configuration ---
// SMCLK (8MHz) / 8 = 1MHz Timer A0 clock.
#define TA_CLK_DIVIDER      8
#define T_UNIT              1       // 1 count per 1 microsecond (1 MHz clock)

// --- NEC Protocol Timings (Standard) ---
#define NEC_LEADER_PULSE_US 9000
#define NEC_LEADER_SPACE_US 4500
#define NEC_BIT_PULSE_US    562
#define NEC_BIT_SPACE_0_US  562
#define NEC_BIT_SPACE_1_US  1687
#define NEC_STOP_PULSE_US   562

// --- NEC Data Configuration ---
#define NEC_CODE_P33   0xBA45FF45UL
#define NEC_CODE_P36   0xBA46FF00UL
#define NEC_CODE_P37   0xBA47FF45UL
#define NEC_CODE_P22   0xBA48FF45UL
#define NEC_CODE_P13   0xBA49FF00UL

// Global state variables
volatile uint8_t  g_bit_index = 0;
volatile uint8_t  g_transmit_active = 0;
volatile uint32_t g_current_nec_data = NEC_CODE_P33;

// --- Function Prototypes ---
void init_pwm_carrier(void);
void init_timer_a0_timing(void);
void init_buttons(void);
void start_pwm_output(void);
void stop_pwm_output(void);
void set_timer_a0_delay(uint16_t us);
void start_nec_transmission(void);
void debounce_delay(void);

// =========================================================================
//                                   MAIN
// =========================================================================
void main(void)
{
    WDTCTL = WDTPW | WDTHOLD;

    // Configure DCO to 8MHz SMCLK (Standard for MSP430FR)
    CSCTL0_H = CSKEY >> 8;
    CSCTL1 = DCOFSEL_3 | DCORSEL;
    CSCTL2 = SELA__VLOCLK | SELS__DCOCLK | SELM__DCOCLK;
    CSCTL3 = DIVA__1 | DIVS__1 | DIVM__1;
    CSCTL0_H = 0;

    PM5CTL0 &= ~LOCKLPM5;

    init_pwm_carrier();
    init_timer_a0_timing();
    init_buttons();

    // Configure Timer A1 for debounce delay (ACLK source)
    TA1CCTL0 = CCIE;

    __enable_interrupt();

    // Sleep until button pressed
    while (1)
    {
        __bis_SR_register(LPM0_bits | GIE);
        __no_operation();
    }
}

// =========================================================================
//                             INITIALIZATION
// =========================================================================

void init_pwm_carrier(void)
{
    // P2.7 = TB0.6
    P2SEL0 |= BIT7;
    P2SEL1 &= ~BIT7;
    P2DIR  |= BIT7;

    TB0CCR0  = PWM_PERIOD;
    TB0CCTL6 = OUTMOD_7;
    TB0CCR6  = DUTY_CYCLE_50;

    TB0CTL = TBSSEL__SMCLK | MC__STOP | TBCLR;
}

void init_timer_a0_timing(void)
{
    // Using ID__8 for 1MHz clock to prevent overflow of 9000 counts
    TA0CTL  = TASSEL__SMCLK | ID__8 | MC__STOP | TACLR;
    TA0CCTL0 = CCIE;
}

void init_buttons(void)
{
    // --- Port 3 buttons: P3.3, P3.6, P3.7 ---
    P3DIR &= ~(BIT3 | BIT6 | BIT7);         // Inputs
    P3REN |=  (BIT3 | BIT6 | BIT7);         // Enable pull resistors
    P3OUT |=  (BIT3 | BIT6 | BIT7);         // Pull-up
    P3IES |=  (BIT3 | BIT6 | BIT7);         // High-to-low edge
    P3IFG &= ~(BIT3 | BIT6 | BIT7);         // Clear flags
    P3IE  |=  (BIT3 | BIT6 | BIT7);         // Enable interrupts

    // --- Port 2 button: P2.2 ---
    P2DIR &= ~BIT2;                         // Input
    P2REN |=  BIT2;                         // Enable pull resistor
    P2OUT |=  BIT2;                         // Pull-up
    P2IES |=  BIT2;                         // High-to-low edge
    P2IFG &= ~BIT2;                         // Clear flag
    P2IE  |=  BIT2;                         // Enable interrupt

    // --- Port 1 button: P1.3 ---
    P1DIR &= ~BIT3;                         // Input
    P1REN |=  BIT3;                         // Enable pull resistor
    P1OUT |=  BIT3;                         // Pull-up
    P1IES |=  BIT3;                         // High-to-low edge
    P1IFG &= ~BIT3;                         // Clear flag
    P1IE  |=  BIT3;                         // Enable interrupt
}

// =========================================================================
//                           CONTROL FUNCTIONS
// =========================================================================

void start_pwm_output(void)
{
    TB0CTL |= MC__UP;
}

void stop_pwm_output(void)
{
    TB0CTL &= ~MC_3;
    P2OUT  &= ~BIT7;
}

void set_timer_a0_delay(uint16_t us)
{
    TA0CCR0 = us * T_UNIT;
    TA0CTL &= ~MC_3;   // Stop timer first
    TA0R = 0;          // Reset counter
    TA0CTL |= MC__UP;  // Start timer
}

void start_nec_transmission(void)
{
    if (g_transmit_active)
        return;

    g_bit_index       = 0;
    g_transmit_active = 1;

    // Ensure clean state before starting
    TB0CTL &= ~MC_3;   // Stop PWM if running
    P2OUT  &= ~BIT7;   // Clear output pin
    TA0CTL &= ~MC_3;   // Stop timing timer
    TA0CTL |= TACLR;   // Clear Timer A0
    TA0R = 0;          // Reset counter

    // Start with the Leader Pulse
    start_pwm_output();
    set_timer_a0_delay(NEC_LEADER_PULSE_US);
}

void debounce_delay(void)
{
    // ACLK (32768 Hz) for ~100ms delay: 32768 * 0.1s = 3276
    TA1CCR0 = 3276;
    TA1CTL  = TASSEL__ACLK | MC__UP | TACLR;

    // Wait in LPM3 until Timer A1 wakes us up
    __bis_SR_register(LPM3_bits | GIE);

    // Stop the timer
    TA1CTL = MC__STOP | TACLR;
}

// =========================================================================
//                         INTERRUPT SERVICE ROUTINES
// =========================================================================

// ===== TIMER0_A0 ISR (NEC Timing) =====
#if defined(__TI_COMPILER_VERSION__) || defined(__IAR_SYSTEMS_ICC__)
#pragma vector = TIMER0_A0_VECTOR
__interrupt void TIMER0_A0_ISR(void)
#elif defined(__GNUC__)
void __attribute__ ((interrupt(TIMER0_A0_VECTOR))) TIMER0_A0_ISR(void)
#else
#error Compiler not supported!
#endif
{
    TA0CTL &= ~MC_3; // Stop timer

    if (!g_transmit_active)
        return;

    if (g_bit_index == 0) // Step 0: Leader Pulse complete -> Start Leader Space
    {
        stop_pwm_output();
        set_timer_a0_delay(NEC_LEADER_SPACE_US);
        g_bit_index++;
    }
    else if (g_bit_index <= 64) // Steps 1 to 64: Data (32 Pulses / 32 Spaces)
    {
        // Transmit LSB first (bit 0 to bit 31)
        uint8_t bit_num = (g_bit_index - 1) / 2;

        if (g_bit_index % 2 != 0) // Odd steps (Pulse)
        {
            start_pwm_output();
            set_timer_a0_delay(NEC_BIT_PULSE_US);
        }
        else // Even steps (Space)
        {
            stop_pwm_output();

            // Check the value of the bit whose pulse was just sent
            if (g_current_nec_data & (1UL << bit_num))
                set_timer_a0_delay(NEC_BIT_SPACE_1_US);
            else
                set_timer_a0_delay(NEC_BIT_SPACE_0_US);
        }

        g_bit_index++; // Increment the step counter
    }
    else if (g_bit_index == 65) // Step 65: Stop Pulse
    {
        start_pwm_output();
        set_timer_a0_delay(NEC_STOP_PULSE_US);
        g_bit_index++;
    }
    else if (g_bit_index == 66) // Step 66: Transmission complete
    {
        stop_pwm_output();
        g_transmit_active = 0;
        __bic_SR_register_on_exit(LPM0_bits);
    }
}

// ===== TIMER1_A0 ISR (Debounce Timer) =====
#if defined(__TI_COMPILER_VERSION__) || defined(__IAR_SYSTEMS_ICC__)
#pragma vector=TIMER1_A0_VECTOR
__interrupt void TIMER1_A0_ISR (void)
#elif defined(__GNUC__)
void __attribute__ ((interrupt(TIMER1_A0_VECTOR))) TIMER1_A0_ISR (void)
#else
#error Compiler not supported!
#endif
{
    __bic_SR_register_on_exit(LPM3_bits);
}

// ===== PORT3_ISR (Buttons on P3.3, P3.6, P3.7) =====
#if defined(__TI_COMPILER_VERSION__) || defined(__IAR_SYSTEMS_ICC__)
#pragma vector = PORT3_VECTOR
__interrupt void PORT3_ISR(void)
#elif defined(__GNUC__)
void __attribute__ ((interrupt(PORT3_VECTOR))) PORT3_ISR(void)
#else
#error Compiler not supported!
#endif
{
    uint8_t flags = P3IFG & (BIT3 | BIT6 | BIT7);

    if (flags & BIT3)
    {
        P3IFG &= ~BIT3;
        P3IE &= ~BIT3;
        g_current_nec_data = NEC_CODE_P33;
        start_nec_transmission();
        debounce_delay();
        P3IE |= BIT3;
    }
    else if (flags & BIT6)
    {
        P3IFG &= ~BIT6;
        P3IE &= ~BIT6;
        g_current_nec_data = NEC_CODE_P36;
        start_nec_transmission();
        debounce_delay();
        P3IE |= BIT6;
    }
    else if (flags & BIT7)
    {
        P3IFG &= ~BIT7;
        P3IE &= ~BIT7;
        g_current_nec_data = NEC_CODE_P37;
        start_nec_transmission();
        debounce_delay();
        P3IE |= BIT7;
    }

    __bic_SR_register_on_exit(LPM0_bits);
}

// ===== PORT2_ISR (Button on P2.2) =====
#if defined(__TI_COMPILER_VERSION__) || defined(__IAR_SYSTEMS_ICC__)
#pragma vector = PORT2_VECTOR
__interrupt void PORT2_ISR(void)
#elif defined(__GNUC__)
void __attribute__ ((interrupt(PORT2_VECTOR))) PORT2_ISR(void)
#else
#error Compiler not supported!
#endif
{
    if (P2IFG & BIT2)
    {
        P2IFG &= ~BIT2;
        P2IE &= ~BIT2;
        g_current_nec_data = NEC_CODE_P22;
        start_nec_transmission();
        debounce_delay();
        P2IE |= BIT2;
    }

    __bic_SR_register_on_exit(LPM0_bits);
}

// ===== PORT1_ISR (Button on P1.3) =====
#if defined(__TI_COMPILER_VERSION__) || defined(__IAR_SYSTEMS_ICC__)
#pragma vector = PORT1_VECTOR
__interrupt void PORT1_ISR(void)
#elif defined(__GNUC__)
void __attribute__ ((interrupt(PORT1_VECTOR))) PORT1_ISR(void)
#else
#error Compiler not supported!
#endif
{
    if (P1IFG & BIT3)
    {
        P1IFG &= ~BIT3;
        P1IE &= ~BIT3;
        g_current_nec_data = NEC_CODE_P13;
        start_nec_transmission();
        debounce_delay();
        P1IE |= BIT3;
    }

    __bic_SR_register_on_exit(LPM0_bits);
}
